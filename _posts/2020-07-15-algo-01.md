---
title: 시간복잡도(Time Complexity)
date: 2020-07-15 00:00:00
categories:
- algorithm
- c++
tags:
- algorithm
- c++
---

# 💡시간복잡도

{% highlight c %}
int func1(int arr[], int n) {
	int cnt = 0; // 1) 연산 +1 
  // 2) i에 초기값 0 대입 : 연산 +1
  // 3) n번에 거쳐 반복되는 일인데, i가 n보다 작은지 확인하고(+1), 작을 경우 1을 증가시키니 : 연산 +2
	for(int i = 0; i < n ; i++) { 
    // 4) 나머지 계산(+1), 일치하는지 확인하는지 확인(+1) : 연산 +2
		if(arr[i] % 5 == 0) cnt++; // 5) 5의 배수일 때 증가 : 연산 +1
	}
	return cnt; // 6) 연산 +1
}
{% endhighlight %}

1) + 2) + n * ( 3)+ 4)+ 5) ) + 6) = 1 + 1 + n * ( 2 + 2 + 1  ) + 1 = 5n + 3

## ⏰ 시간 복잡도 (Time Complexity)

입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계

### 👌빅오표기법

 주어진 식을 값이 가장 큰 대표항만 남겨서 나타내는 방법

 ex)

O(N) : 5N+3, 2N+10lgN

O(N^2) : N^2+2N+4

## ✍️예제문제

> N이 제곱수이면 1을 반환하고, 제곱수가 아니면 0을 반환하는 함수 func3(int N)을 작성하라. N은 10억 이하의 자연수

{% highlight c %}

int func3(int N) {
    for(int i=1;i*i<=N;i++) {
        if(i*i==N) return 1;
    }
    return 0;
}

{% endhighlight %}

시간복잡도 : O(√N)

> N이하의 수 중에서 가장 큰 2의 거듭제곱수를 반환하는 함수 func4(int N)을 작성하라. N은 10억 이하의 자연수이다.

{% highlight c %}

int func4(int N) {
    int val=1;
    while(2*val <=N) val *=2;
    return val;
}

{% endhighlight %}
